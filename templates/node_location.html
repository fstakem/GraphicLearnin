<div id="chart" style="margin:20px"></div>

<style type="text/css">


	.link 
	{
	  	stroke: #000;
	  	stroke-width: 2.0px;
	}

	.node 
	{
	  	cursor: move;
	  	fill: #ccc;
	  	stroke: #000;
	  	stroke-width: 1.5px;
	}

	.location
	{
		cursor: move;
	  	fill: red;
	  	stroke: #000;
	  	stroke-width: 1.5px;
	}

	.location.condensed
	{
		cursor: move;
	  	fill: blue;
	  	stroke: #000;
	  	stroke-width: 1.5px;
	}

	.host
	{
	  	fill: #ccc;
	  	stroke: #000;
	  	stroke-width: 1.5px;
	}

	.node.fixed 
	{
	  	fill: #f00;
	}

</style>

<script src="http://d3js.org/d3.v3.min.js"></script>

<script type="text/javascript">
	
	// Graphic parameters
	var width  = 600;
	var height = 400;
	var link_distance = 40;
	var node_charge = -500;
	var location_height = 30;
	var location_width = 30;
	var host_height = 30;
	var host_width = 30;

	// Initial data
	var nodes = [
	    			{id: 0, name: "GaTech", node_type: "location", fixed: true, x: 100, y: 100},
	    			{id: 1, name: "Host 1", node_type: "host", fixed: false, x: 200, y: 200},
	    			{id: 2, name: "Host 2", node_type: "host", fixed:false, x: 300, y: 300}
	  			];
	var links = [
	    			{source: nodes[0], target: nodes[1]},
	    			{source: nodes[1], target: nodes[2]}
	  			];

	var force = d3.layout.force()
	    		  .size([width, height])
	    		  .charge(-400)
	    		  .linkDistance(40)
	    		  .on("tick", tick);

	var drag = force.drag()
	    			.on("dragstart", dragstart);

	var svg = d3.select('#chart')
	  			.append('svg')
	  			.attr('width', width)
	  			.attr('height', height);

	var link = svg.selectAll(".link");
	var node = svg.selectAll(".node");

	force.nodes(nodes)
	     .links(links)
	     .start();

	// Functions for node and links
	var getShape = function(type, x, y, w, h)
	{
		var points;
		var h = 10;
		var w = 10;

		if(type == 'location')
		{
			h = location_height;
			w = location_width;
			points = [ [x, y], [x + w, y], [x + w, y + h], [x, y + h]];
		}
		else if (type == 'host')
		{
			h = host_height;
			w = host_width;
			points = [[x + w/2, y], [x + w/2 , y], [x + w, y + h], [x, y + h]];
		}
		else
		{
			points = [[x + w/2, y], [x + w/2 , y], [x + w, y + h], [x, y + h]];
		}
    	
    	return d3.svg.line()(points)
	}
	

	

  	link = link.data(links)
    		   .enter().append("line")
      		   .attr("class", "link");

    var node_wrapper = node.data(nodes)
    		   		   	   .enter().append("g")
      		           	   .attr("class", "node")
      		           	   .attr('x', function(d){return d.x})
      		           	   .attr('y', function(d){return d.y})
      		           	   .call(drag);

    node = node_wrapper.append('path')
    				.attr("class", function(d) { return d.node_type })
					.attr('d', function(d){return getShape(d.node_type, d.x , d.y) })
					.attr('x', function(d){return d.x})
					.attr('y', function(d){return d.y})
					.call(force.drag);

  	//node = node.data(nodes)
    //		   .enter().append("circle")
    //  		   .attr("class", function(d) { return d.type })
    //  		   .attr("r", 12)
    //  		   .call(drag);

    
    console.log("---------------------------------------");
    

    //console.log ( node );

    //var location = svg.selectAll(".location");
    //var host = svg.selectAll(".host");

    //console.log ( location );

	// Functions for updating the interface
	function tick()
	{
		link.attr("x1", function(d) { return d.source.x; })
	      	.attr("y1", function(d) { return d.source.y; })
	      	.attr("x2", function(d) { return d.target.x; })
	      	.attr("y2", function(d) { return d.target.y; });

	  	node.attr("cx", function(d) { return d.x; })
	      	.attr("cy", function(d) { return d.y; });

	}

	function update() 
	{
		path = path.data(links);
	}

	// User interaction functions
	function dragstart(d) 
	{
	  	//d.fixed = true;
	  	//d3.select(this).classed("fixed", true);
	}


</script>