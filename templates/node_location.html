<div id="chart" style="margin:20px"></div>

<style type="text/css">


	.link 
	{
	  	stroke: #000;
	  	stroke-width: 2.0px;
	}

	.node 
	{
	  	cursor: move;
	  	fill: #ccc;
	  	stroke: #000;
	  	stroke-width: 1.5px;
	}

	.location
	{
		cursor: move;
	  	fill: red;
	  	stroke: #000;
	  	stroke-width: 1.5px;
	}

	.location.condensed
	{
		cursor: move;
	  	fill: blue;
	  	stroke: #000;
	  	stroke-width: 1.5px;
	}

	.host
	{
		cursor: move;
	  	fill: blue;
	  	stroke: #000;
	  	stroke-width: 1.5px;
	}

	.node.fixed 
	{
	  	fill: #f00;
	}

</style>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="/static/js/sprintf.js"></script>

<script type="text/javascript">

	// Graphic parameters
	var width  = 600;
	var height = 400;
	var link_distance = 40;
	var node_charge = -500;
	var location_height = 30;
	var location_width = 30;
	var host_inner_radius = 0;
	var host_outer_radius = 14;

	// Initial data
	var nodes = [
	    			{id: 0, name: "GaTech", node_type: "location", hosts: [], fixed: true, x: 100, y: 100},
	    			{id: 1, name: "Host 1", node_type: "host", hosts: [], fixed: false, x: 200, y: 200},
	    			{id: 2, name: "Host 2", node_type: "host", hosts: [], fixed:false, x: 300, y: 300}
	  			];
	var links = [
	    			{source: nodes[0], target: nodes[1]},
	    			{source: nodes[0], target: nodes[2]}
	  			];

	var force = d3.layout.force()
	    		  .size([width, height])
	    		  .charge(-400)
	    		  .linkDistance(40)
	    		  .on("tick", tick);

	var drag = force.drag()
	    			.on("dragstart", dragstart);

	var svg = d3.select('#chart')
	  			.append('svg')
	  			.attr('width', width)
	  			.attr('height', height);

	var link = svg.selectAll(".link");
	var node = svg.selectAll(".node");

	force.nodes(nodes)
	     .links(links)
	     .start();

	// Events
	//var drag = d3.behavior.drag()
	//		.origin(Object)
	//		.on("drag", move);

	// Functions for node and links
	var lineFunction = d3.svg.line()
                         .x(function(d) { return d.x; })
                         .y(function(d) { return d.y; })
                         .interpolate("linear");

	var getShape = function(type)
	{
		var x = 0;
		var y = 0;
		var h = 10;
		var w = 10;
		
		if(type == 'location')
		{
			h = location_height;
			w = location_width;
			x = -w/2;
			y = -h/2;

			var points = [ 
					   		{"x": x, "y": y},
					   		{"x": x + w, "y": y},
					   		{"x": x + w, "y": y + h},
					   		{"x": x, "y": y + h}, 
					   		{"x": x, "y": y} 
					 	 ];

			return lineFunction(points);
		}
		else if (type == 'host')
		{
        	var orbital_arc = d3.svg.arc()
						    	.startAngle(0)
						    	.endAngle(6.28318531)
						    	.innerRadius(host_inner_radius)
						    	.outerRadius(host_outer_radius); 
			return orbital_arc();
		}
		else if(type == "triangle")
		{
			x = x - w/2;
			y = y - h/2;

			var points = [ 
					   		{"x": x + w/2, "y": y},
					   		{"x": x + w, "y": y + h},
					   		{"x": x, "y": y + h},
					   		{"x": x + w/2, "y": y} 
					 	 ];

			return lineFunction(points)
		}
		else
		{
			x = x - w/2;
			y = y - h/2;

			var points = [ 
					   		{"x": x, "y": y},
					   		{"x": x + w, "y": y},
					   		{"x": x + w, "y": y + h},
					   		{"x": x, "y": y + h}, 
					   		{"x": x, "y": y} 
					 	 ];

			return lineFunction(points)
		}
    	
    	return lineFunction(points)
	}
	

	

  	link = link.data(links)
    		   .enter().append("line")
      		   .attr("class", "link");

    var node_wrapper = node.data(nodes)
    		   		   	   .enter().append("g")
      		           	   .attr("class", "node")
      		           	   .call(drag)
      		           	   .attr('x', function(d){return d.x})
						   .attr('y', function(d){return d.y})
      		           	   .append("g")
      		           	   .attr("class", function(d) { return d.node_type });
      		           	   
    node = node_wrapper.append('path')
					.attr('d', function(d){return getShape(d.node_type) });

	var xx = svg.selectAll(".location")
				.append("text")
				.attr("dx", 0)
				.attr("dy", ".35em")
				.attr("text-anchor", "middle")
    			.text(function(d) { return d.name; });
    

	

  	//node = node.data(nodes)
    //		   .enter().append("circle")
    //  		   .attr("class", function(d) { return d.type })
    //  		   .attr("r", 12)
    //  		   .call(drag);

    
    console.log("---------------------------------------");
    

    //console.log ( node );

    //var location = svg.selectAll(".location");
    //var host = svg.selectAll(".host");

    //console.log ( location );

	// Functions for updating the interface
	function tick()
	{
		link.attr("x1", function(d) { return d.source.x; })
	      	.attr("y1", function(d) { return d.source.y; })
	      	.attr("x2", function(d) { return d.target.x; })
	      	.attr("y2", function(d) { return d.target.y; });

	    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

	  	//node.attr("cx", function(d) { return d.x; })
	      	//.attr("cy", function(d) { return d.y; });

	    //location.attr("cx", function(d) { return d.x; })
	      	//.attr("cy", function(d) { return d.y; });

	}

	function update() 
	{
		path = path.data(links);
	}

	// User interaction functions
	function dragstart(d) 
	{
	  	//d.fixed = true;
	  	//d3.select(this).classed("fixed", true);
	}

	function move()
	{
		/*
		var dragTarget = d3.select(this);

		console.log("d3.event.x:"+d3.event.x+" d3.event.y:"+d3.event.y);
		console.log(dragTarget)
		console.log("target.x:"+dragTarget.attr('x')+" target.y:"+dragTarget.attr('y'));

		var x = d3.event.x - parseInt(dragTarget.attr('x'));
		var y = d3.event.y - parseInt(dragTarget.attr("y"));

		dragTarget
			.attr("transform", "translate(" + x + "," + y + ")")
			*/
	}


</script>